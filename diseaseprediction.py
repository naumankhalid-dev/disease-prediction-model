# -*- coding: utf-8 -*-
"""DiseasePrediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T9NOkF7jzwKkjU2py3HYAS9pZltuXPW8

Disease Prediction from Medical Data (Diabetes)
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix, classification_report

"""LOADING AND EXPLORING DATASET"""

from google.colab import files
uploaded = files.upload()

df = pd.read_csv("diabetes.csv")
df.head()

print("Shape:", df.shape)
print("\nInfo:")
print(df.info())
print("\nMissing values:\n", df.isnull().sum())
print("\nDescriptive Stats:\n", df.describe())

"""VISUALIZE DATA"""

plt.figure(figsize=(6,4))
sns.countplot(x='Outcome', data=df)
plt.title("Diabetes Outcome Distribution")
plt.show()

plt.figure(figsize=(10,8))
sns.heatmap(df.corr(), annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.show()

"""DATA PREPROCESSING"""

cols_with_zero = ["Glucose","BloodPressure","SkinThickness","Insulin","BMI"]
df[cols_with_zero] = df[cols_with_zero].replace(0, np.nan)

df[cols_with_zero] = df[cols_with_zero].fillna(df[cols_with_zero].mean())

X = df.drop("Outcome", axis=1)
y = df["Outcome"]


scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

"""DATA SPLIT"""

X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.2, random_state=42, stratify=y
)

print("Training samples:", X_train.shape[0])
print("Testing samples:", X_test.shape[0])

"""TRAINING MODELS"""

models = {
    "Logistic Regression": LogisticRegression(max_iter=1000),
    "SVM": SVC(probability=True),
    "Random Forest": RandomForestClassifier(n_estimators=100, random_state=42),
    "XGBoost": XGBClassifier(eval_metric="logloss", random_state=42)
}

trained_models = {}
for name, model in models.items():
    model.fit(X_train, y_train)
    trained_models[name] = model

"""MODEL EVALUATION"""

from sklearn.model_selection import cross_val_score, StratifiedKFold

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

results = []

for name, model in trained_models.items():
    acc = cross_val_score(model, X_scaled, y, cv=cv, scoring="accuracy").mean()
    prec = cross_val_score(model, X_scaled, y, cv=cv, scoring="precision").mean()
    rec = cross_val_score(model, X_scaled, y, cv=cv, scoring="recall").mean()
    f1 = cross_val_score(model, X_scaled, y, cv=cv, scoring="f1").mean()
    auc = cross_val_score(model, X_scaled, y, cv=cv, scoring="roc_auc").mean()

    results.append([name, acc, prec, rec, f1, auc])

results_df = pd.DataFrame(results, columns=["Model","Accuracy","Precision","Recall","F1-Score","ROC-AUC"])
results_df

"""MODEL SELECTION"""

plt.figure(figsize=(8,5))
sns.barplot(data=results_df, x="Model", y="F1-Score")
plt.title("Model Comparison - F1 Score (5-Fold CV)")
plt.show()

best_model_name = results_df.sort_values(by="F1-Score", ascending=False).iloc[0]["Model"]
print("Best Model based on F1-Score:", best_model_name)

"""MODEL COMPARISON"""

# Compare model accuracies
model_names = list(trained_models.keys())
accuracies = [accuracy_score(y_test, trained_models[m].predict(X_test)) for m in model_names]

plt.figure(figsize=(8,5))
plt.bar(model_names, accuracies, color="skyblue", edgecolor="black")
plt.title("Model Accuracy Comparison")
plt.ylabel("Accuracy")
plt.ylim(0, 1)
for i, acc in enumerate(accuracies):
    plt.text(i, acc + 0.01, f"{acc:.2f}", ha="center", fontsize=10, fontweight="bold")
plt.show()

"""MODEL SELECTION AND SAMPLE PREDICTIONS"""

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay


print(f"Best Model Selected: {best_model_name}\n")

print("Classification Report:\n")
print(classification_report(y_test, y_pred_best))


cm = confusion_matrix(y_test, y_pred_best)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=best_model.classes_)
disp.plot(cmap="Blues")
plt.title(f"Confusion Matrix - {best_model_name}")
plt.show()


samples = X_test[:5]
predictions = best_model.predict(samples)
probabilities = best_model.predict_proba(samples)

print("\nSample Predictions:")
for i, (pred, probs) in enumerate(zip(predictions, probabilities)):
    status = "Likely Diabetes" if pred == 1 else "Likely No Diabetes"
    print(f"Patient {i+1}: {status} | Probabilities -> No Diabetes: {probs[0]:.2f}, Diabetes: {probs[1]:.2f}")

"""In this project, I built a disease prediction system using structured medical data. I applied multiple machine learning algorithms (Logistic Regression, SVM, Random Forest, XGBoost) and compared their performance. After evaluation, the best-performing model was selected. The results include accuracy metrics, confusion matrix, and sample predictions for patients, showing the probability of having diabetes. This project enhanced my understanding of data preprocessing, model evaluation, and practical application of ML in healthcare."""